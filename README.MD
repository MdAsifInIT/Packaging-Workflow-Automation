# App Packaging Automation

AI-assisted application packaging automation using:

- Jenkins (CI)
- n8n (cloud) for intake & orchestration
- PSAppDeployToolkit (PSADT) for packaging
- OpenAI API for silent-switch discovery & PSADT script generation

## Table of Contents

- [Repo Layout](#repo-layout)
- [Quickstart](#quickstart)
- [Contributing](#contributing)
- [License](#license)
- [Step-by-step guide — build your automated packaging workflow](#step-by-step-guide--build-your-automated-packaging-workflow)

## Repo Layout

- `templates/` — PSADT template, n8n workflows, Jenkinsfile examples
- `examples/` — sample app package (manifest + PSADT script)
- `scripts/` — VM test runner, helpers
- `docs/` — architecture, runbook, onboarding
- `.github/` — community files & CI

## Quickstart

1. Clone repo.
2. Read `docs/onboarding.md`.
3. Import `templates/n8n-workflows/intake-openai.json` into n8n.
4. Configure Jenkins to run `templates/jenkins-pipelines/Jenkinsfile`.
5. Store OpenAI API key in n8n credentials (do NOT commit keys).

## Contributing

See `CONTRIBUTING.md`.

## License

MIT. See `LICENSE`.

## Step-by-step guide — build your automated packaging workflow

Below is a practical, hands-on, runnable plan that takes you from repo + templates to a working n8n → OpenAI → PR → Jenkins → ephemeral VM verification loop. Where helpful I include ready-to-paste files and command examples. Follow sequentially; each major step contains sub-tasks and verification checks.

---

### 0 — Assumptions & prerequisites (what you need before starting)

- GitHub repo access and ability to create branches/PRs and webhooks.
- n8n cloud account with access to GitHub, storage (S3/Azure blob), and ability to store credentials.
- OpenAI API key (store in n8n vault).
- Jenkins controller + ability to provision Windows agents or ephemeral Windows VMs (Azure, AWS, GCP).
- Windows builder image with PowerShell 7, PSAppDeployToolkit (PSADT), WinRM/SSH as needed.
- Basic PowerShell & Git knowledge.

If any of those are missing, set them up first.

---

### 1 — Repo & templates (create the initial codebase) — Day 0–1

#### 1.1 Repo structure

Create `packaging-repo` with this layout:

```text
packaging-repo/
  templates/
    psadt-template/
      Deploy-Application.ps1.template
      AppDeployToolkit/            # vendor PSADT files (tracked or referenced)
      Files/                       # placeholder for installers
      manifest.schema.json
  products/
    # automation will create per-product folders here
  .github/
    workflows/
      package-ci.yml   # optional: GitHub Actions CI if you later want it
  n8n-workflows/
  scripts/
    run-candidate-tests.ps1
  Jenkinsfile
  README.md

```

Create the repo and push initial files.

#### 1.2 `manifest.schema.json` (copy into `templates/manifest.schema.json`)

This schema is what your OpenAI prompt will target and what PRs must comply with.

```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "type": "object",
  "properties": {
    "product": { "type": "string" },
    "vendor": { "type": "string" },
    "version": { "type": "string" },
    "source_url": { "type": "string", "format": "uri" },
    "checksum": { "type": "string" },
    "install_context": { "type": "string", "enum": ["System", "User"] },
    "prereqs": { "type": "array", "items": { "type": "string" } },
    "human_review": { "type": "boolean" },
    "notes": { "type": "string" },
    "product_code": { "type": "string" },
    "uninstall_command": { "type": "string" },
    "verification_hints": { "type": "array", "items": { "type": "string" } },
    "confidence_overall": { "type": "number", "minimum": 0, "maximum": 1 }
  },
  "required": [
    "product",
    "vendor",
    "version",
    "source_url",
    "checksum",
    "install_context",
    "human_review"
  ]
}
```

#### 1.3 PSADT template

Place this at `templates/psadt-template/Deploy-Application.ps1.template`. (This is a template — the n8n/LLM will fill placeholders or produce a filled `Deploy-Application.ps1`.)

```powershell
<#
.SYNOPSIS
  PSADT scaffold generated by automation.
#>

[string]$manifestPath = Join-Path $PSScriptRoot 'manifest.json'
$manifest = Get-Content -Raw -Path $manifestPath | ConvertFrom-Json

$installer = Join-Path $PSScriptRoot 'Files\source_installer.exe'
$candidates = Get-Content -Raw -Path (Join-Path $PSScriptRoot 'candidates.json') | ConvertFrom-Json

# pick primary candidate
$primary = $candidates | Sort-Object -Property @{Expression={[double]$_.confidence}} -Descending | Select-Object -First 1

Function Install-MyApp {
  Write-Log -Message "Installing $($manifest.product) using $($primary.command)" -Severity 'INFO'
  $cmd = $primary.command -replace '<installer>', $installer
  Execute-Process -Path "powershell.exe" -Parameters "-NoProfile -ExecutionPolicy Bypass -Command `"$cmd`"" -WindowStyle Hidden -Wait -ErrorAction Stop

  # layered verification (simple example)
  $installedExe = "C:\Program Files\$($manifest.product)\$($manifest.product).exe"
  if (Test-Path $installedExe) {
    Write-Log -Message "Verification OK: $installedExe" -Severity 'INFO'
    return $true
  } else {
    Write-Log -Message "Verification failed" -Severity 'ERROR'
    return $false
  }
}

Function Uninstall-MyApp {
  Write-Log -Message "Uninstalling $($manifest.product)" -Severity 'INFO'
  if ($manifest.uninstall_command) {
    Execute-Process -Path "powershell.exe" -Parameters "-NoProfile -ExecutionPolicy Bypass -Command `"$($manifest.uninstall_command)`"" -WindowStyle Hidden -Wait -ErrorAction Stop
  } else {
    Write-Log -Message "No uninstall command provided" -Severity 'WARN'
  }
}

Try {
  If ($DeployMode -eq 'Install') { if (-not (Install-MyApp)) { Throw 'Install verification failed' } }
  ElseIf ($DeployMode -eq 'Uninstall') { Uninstall-MyApp }
} Catch {
  Write-Log -Message "Error: $($_.Exception.Message)" -Severity 'ERROR'
  Exit-Script -ExitCode 70000
}

```

Commit templates.

---

### 2 — Build n8n workflow: intake → analysis → LLM → PR — Day 1–2

This section explains nodes and what each does. Implement in n8n cloud.

#### 2.1 Webhook node (trigger)

- Expose an authenticated webhook endpoint.
- Accept payload:

```json
{
  "ticket_id": "PKG-123",
  "installer_url": "https://vendor.example/MyAppSetup.exe",
  "release_notes": "MyApp v3.2.1 - requires .NET 6",
  "requested_by": "packager@company.com"
}
```

- Validate required fields, respond with 202 + PR link placeholder later.

#### 2.2 Download & metadata node (HTTP Request + Storage)

- HEAD installer URL to get content-type and size.
- Download binary to cloud storage (S3 / Azure blob). Save as `artifacts/<sha256>.bin`.
- Compute SHA256 (either in n8n function node or via cloud function). Save content-type, size, sha256.

#### 2.3 Deterministic classifier (Function / Execute Command)

Run quick, deterministic checks to reduce LLM load and increase safety:

- If file is MSI: extract ProductCode and properties using `sigcheck`/`lessmsi` or by mounting MSI (you can call a small cloud function). Example results saved as `msi_properties` JSON.
- If file is EXE: run `strings` (first N KB) to look for known installer framework markers (`Inno`, `NSIS`, `InstallShield`, `/VERYSILENT`, `/S`, `/silent`, `msiexec`).
- Produce `strings_snippet` (truncated) and `file_type` (msi|exe|zip|unknown).

Store all metadata to audit.

#### 2.4 Build & send OpenAI prompt

Use the strict system + user messages below. In n8n use OpenAI node or HTTP Request:

**System message (strict)**:

```text
You are a packaging assistant. Output MUST be valid JSON exactly matching the schema in the user message. Do not output comments or text. If uncertain about a field, set its value to "TODO" and set human_review:true. Use confidence values between 0.0 and 1.0. Temperature must be 0.

```

**User message** (replace placeholders dynamically with collected metadata):

```text
Schema:
{
 "manifest":{ "product":"", "vendor":"", "version":"", "source_url":"", "checksum":"", "install_context":"", "prereqs":[],"human_review":true,"notes":"","product_code":"TODO","uninstall_command":"TODO","verification_hints":[],"confidence_overall":0.0 },
 "candidates":[ {"id":"", "command":"", "framework":"MSI|Inno|NSIS|InstallShield|Burn|Custom|Unknown", "confidence":0.0, "rationale":"" } ],
 "psadt_skeleton":"string",
 "extraction":{"file_type":"exe|msi|zip|unknown", "strings_matches":[], "msi_properties":{} }
}

Input:
{
 "installer_url":"{{installer_url}}",
 "file_signature": { "mime":"{{mime}}","size_bytes":{{size}},"sha256":"{{sha256}}"},
 "release_notes":"{{release_notes}}",
 "strings_snippet":"{{strings_snippet}}",
 "msi_inspection": {{msi_properties_or_empty}}
}

Task:
1) Propose candidate silent install commands (primary first) with framework, confidence (0..1), and short rationale.
2) Fill out manifest fields; set human_review true if any candidate has confidence < 0.80 or any manifest field is TODO.
3) Return a PSAppDeployToolkit Deploy-Application.ps1 skeleton that installs using the primary candidate command and includes verification_hints (registry path, exe path) when possible.
4) Output ONLY JSON matching schema above.

```

**Notes**:

- Use temperature = 0.0 to ensure deterministic output.
- Log both prompt and AI response into your audit storage.

#### 2.5 Parse & validate the JSON

- Validate against `manifest.schema.json`.
- If JSON invalid or parsing fails, mark `human_review = true`, store raw AI output and create PR with `needs-review` label.

#### 2.6 Create branch and commit files (Git/GitHub Node)

On success, create branch `ai/PKG-<ticket>-<sha256>` and commit:

```text
products/<ProductName>/manifest.json      (from AI)
products/<ProductName>/candidates.json    (from AI)
products/<ProductName>/Deploy-Application.ps1  (from psadt_skeleton or template filled)
products/<ProductName>/Files/source_installer.bin (optional or pointer)
products/<ProductName>/README_AI.md       (include human_review flag + raw AI output + brief rationale)

```

Then open PR against `main` with label `ai-generated` and `human_review` status in PR body. Save PR URL.

#### 2.7 Trigger Jenkins

- Option A: let PR webhook trigger Jenkins.
- Option B (recommended): call Jenkins build endpoint with environment variable `PRODUCT=<ProductName>` to run verification immediately. Include PR id & branch.

#### 2.8 Reply to webhook source

- Return PR link and `human_review` flag to the requester via the original system (ticketing system/email).

---

### 3 — Jenkins CI pipeline (create & wire Jenkins) — Day 2–4

Place `Jenkinsfile` at repo root. Example declarative pipeline (Windows agent):

```groovy
pipeline {
  agent { label 'windows' }   // use a label that points to a clean Windows worker or plugin to start ephemeral VM
  options { timestamps() }
  parameters {
    string(name: 'PRODUCT', defaultValue: '', description: 'Product name (from PR or n8n)')
    string(name: 'PR_ID', defaultValue: '', description: 'PR number')
  }
  environment {
    ARTIFACT_DIR = "artifacts"
    OUTPUT_DIR = "test-output"
  }
  stages {
    stage('Checkout') {
      steps { checkout scm }
    }
    stage('Lint PS') {
      steps {
        powershell script: 'Install-Module -Name PSScriptAnalyzer -Force -Scope CurrentUser', returnStatus: true
        powershell script: "Invoke-ScriptAnalyzer -Path .\\products\\${params.PRODUCT}\\Deploy-Application.ps1 || true", returnStatus: true
      }
    }
    stage('Download Installer') {
      steps {
        powershell script: '''
          $m = Get-Content ".\\products\\$env:PRODUCT\\manifest.json" -Raw | ConvertFrom-Json
          $dest = ".\\products\\$env:PRODUCT\\Files\\source_installer.exe"
          Invoke-WebRequest -Uri $m.source_url -OutFile $dest -UseBasicParsing
        '''
      }
    }
    stage('Run candidate tests') {
      steps {
        powershell script: """
          .\\scripts\\run-candidate-tests.ps1 -ManifestPath .\\products\\${params.PRODUCT}\\manifest.json -CandidatesJson .\\products\\${params.PRODUCT}\\candidates.json -ArtifactDir .\\products\\${params.PRODUCT}\\Files -OutputDir .\\${env.OUTPUT_DIR}
        """, returnStatus: false
      }
    }
    stage('Upload Logs') {
      steps {
        archiveArtifacts artifacts: 'test-output/**', allowEmptyArchive: true
      }
    }
  }
  post {
    success { echo 'Verification success' }
    failure { mail to: 'packaging-team@company.com', subject: "Packaging CI failed: ${env.JOB_NAME}", body: "See Jenkins logs" }
  }
}

```

#### 3.1 Jenkins agent & VM lifecycle

- Option 1 (preferred): Jenkins uses an orchestrator plugin to create ephemeral VMs per job (Azure DevTest Labs, cloud images). Each VM generated from a golden image where PSADT & tools are preinstalled.
- Option 2: Long-lived agent but revert snapshot between runs (Hyper-V / VMware).

Ensure Jenkins agent can reach installer source URLs and has rights to write artifacts.

---

### 4 — VM verification script: `run-candidate-tests.ps1` — Day 2–3

Create `scripts/run-candidate-tests.ps1`. This script tries candidates in descending confidence order, runs layered verification, records logs/artifacts, and returns an exit code (0 success, non-0 failure).

```powershell
param(
  [Parameter(Mandatory=$true)][string]$ManifestPath,
  [Parameter(Mandatory=$true)][string]$CandidatesJson,
  [Parameter(Mandatory=$true)][string]$ArtifactDir,
  [string]$OutputDir = ".\test-output"
)

$ErrorActionPreference = 'Stop'
New-Item -Path $OutputDir -ItemType Directory -Force | Out-Null

$manifest = Get-Content $ManifestPath -Raw | ConvertFrom-Json
$candidates = Get-Content $CandidatesJson -Raw | ConvertFrom-Json

# helper: layered verification
function Verify-Installed {
  param($manifest, $verification_hints)
  # Layer 1: MSI product code / registry
  if ($manifest.product_code -and (Get-ChildItem 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall' -Recurse | Where-Object {
      $_.GetValue('ProductCode','') -eq $manifest.product_code
    })) { return @{passed=$true;method='msi-productcode'} }

  # Layer 2: expected exe path
  foreach ($hint in $verification_hints) {
    if ($hint -like '*:\*') { if (Test-Path $hint) { return @{passed=$true;method='exe-path';hint=$hint} } }
    # allow registry hint or shortcut patterns as strings
  }

  # Layer 3: Start Menu/Shortcut checks (look for product in start menu)
  $startmenu = Join-Path $env:ProgramData 'Microsoft\Windows\Start Menu\Programs'
  if (Get-ChildItem -Path $startmenu -Recurse -ErrorAction SilentlyContinue | Where-Object { $_.Name -like "*$($manifest.product)*" }) { return @{passed=$true;method='shortcut'} }

  # Layer 4: smoke test (non-interactive)
  if ($manifest.verification_hints) {
    foreach ($cmd in $manifest.verification_hints) {
      try {
        $parts = $cmd -split ' '
        $exe = $parts[0]
        $args = ($parts | Select-Object -Skip 1) -join ' '
        $proc = Start-Process -FilePath $exe -ArgumentList $args -NoNewWindow -PassThru -ErrorAction SilentlyContinue
        Start-Sleep -Seconds 2
        if ($proc -and $proc.HasExited) { return @{passed=$true;method='smoke';cmd=$cmd} }
      } catch {}
    }
  }
  return @{passed=$false}
}

foreach ($c in $candidates | Sort-Object -Property @{Expression={[double]$_.confidence}} -Descending) {
  Write-Host "Trying candidate $($c.id) (confidence $($c.confidence)): $($c.command)"
  $cmd = $c.command -replace '<installer>', (Join-Path $ArtifactDir 'source_installer.exe')
  $logPath = Join-Path $OutputDir "candidate-$($c.id).log"
  try {
    # Run installer as a background process; capture output
    Start-Process -FilePath "powershell.exe" -ArgumentList "-NoProfile -ExecutionPolicy Bypass -Command `"$cmd`"" -NoNewWindow -Wait -RedirectStandardOutput $logPath -RedirectStandardError $logPath
  } catch {
    "Execution failed: $($_.Exception.Message)" | Out-File $logPath -Append
  }

  Start-Sleep -Seconds 5

  $verify = Verify-Installed -manifest $manifest -verification_hints $manifest.verification_hints
  $result = @{
    id = $c.id
    command = $cmd
    confidence = $c.confidence
    verified = $verify.passed
    verify_method = $verify.method
    log = Get-Content $logPath -Raw
  }
  $result | ConvertTo-Json -Depth 4 | Out-File -FilePath (Join-Path $OutputDir ("result-$($c.id).json")) -Encoding utf8

  if ($verify.passed) {
    Write-Host "Candidate $($c.id) verified via $($verify.method)"
    exit 0
  } else {
    Write-Host "Candidate $($c.id) did not verify."
  }
}

Write-Host "No candidate verified. Exiting with failure."
exit 2

```

**Important**: Extend verification function as you learn product families (services, drivers, registry keys, scheduled tasks).

---

### 5 — PR & human approval logic — Day 3

#### 5.1 PR labels & status

- Use GitHub API or n8n to add labels: `ai-generated` and either `verified-primary` or `needs-review`.
- Use Jenkins status checks: `ci/lint`, `ci/verify`. Jenkins reports success/failure to GitHub.

#### 5.2 Auto-merge policy (enforce rules)

Auto-merge only when:

- Jenkins `ci/verify` passes,
- `human_review` in manifest == false,
- `manifest.confidence_overall >= 0.90` (configurable),
- No open manual blockers.

If any condition not met → leave `needs-review` and notify packaging team with the logs and `candidates.json`.

Implement automation in n8n to perform label changes and auto-merge when checks pass.

---

### 6 — Logging, audit & artifact storage — ongoing

Store the following for each run (immutable storage):

- Installer sha256 and original binary (or pointer).
- Full LLM input prompt and raw response.
- `manifest.json`, `candidates.json`, `Deploy-Application.ps1`.
- Jenkins artifacts: `test-output/**` including `result-*.json`, logs, registry/FS diffs, screenshots.
- PR id, Jenkins build id, run timestamps.

Retention: follow company policy, recommended 90 days by default (increase if required).

---

### 7 — Hardening & safety details (must implement before broad rollout)

- Never put secrets in prompt or logs. Use n8n secret storage & vaults.
- Limit test VM network egress: only allow access to vendor download domains + internal telemetry endpoints. Use firewall or cloud network policies.
- Use snapshot rollback for the VM after each run (ensure previous runs do not contaminate).
- Regularly rotate OpenAI keys and limit access to n8n service account.
- Maintain a list of blocked/unknown installer patterns and require manual review for executables marked `Custom|Unknown`.

---

### 8 — Metrics & feedback loop (measure and improve) — ongoing

Track these KPIs:

- `% packages auto-verified` (goal: increase over time)
- `false-positive rate` (packages marked verified but later reported failing)
- `average CI runtime`
- `human-review rate`
- `most common verification failure reasons`

Use results to:

- tune `confidence_overall` threshold,
- add more deterministic detection rules,
- add product-specific verification hints to LLM prompt (few-shot examples).

---

### 9 — Testing & rollout plan (pilot → production) — 2–4 weeks

## Week 0: Prepare

- create repo, templates, n8n skeleton, Jenkins pipeline and Windows image.

## Week 1: Internal pilot

- Run pilot on 10 pre-approved installers (MSI + known frameworks).
- Evaluate results; ensure verification checks succeed or flag human_review with clear reasons.

## Week 2: Expand pilot

- Add more diverse installers (Inno / NSIS / InstallShield / custom EXE).
- Track false positives; refine prompt and verification_hints.

## Week 3: Harden & partial auto-merge

- Allow auto-merge only for installers that are MSI and meet verification ladder criteria. Keep others in `needs-review`.

## Week 4+: Wider rollout

- Expand auto-merge rule coverage as confidence grows.

---

### 10 — Example: updated OpenAI prompt (final — copy/paste)

**System (strict)**:

```text
You are a packaging assistant. Output MUST be valid JSON exactly matching the schema in the user message. Do not output text outside the JSON. If uncertain about a field, set its value to "TODO" and set human_review:true. Use confidence values between 0.0 and 1.0. Temperature: 0.

```

**User** (dynamic fields inserted by n8n):

```text
Schema:
{... }   // supply manifest + candidates + psadt_skeleton + extraction fields - same as earlier; ensure schema matches manifest.schema.json

Input:
{
 "installer_url":"https://...",
 "file_signature": {"mime":"application/x-msdownload","size_bytes":123456,"sha256":"..."},
 "release_notes":"...",
 "strings_snippet":"...first 10KB of strings...",
 "msi_inspection": { /* msiproperties if present */ }
}

Task:
1) Propose candidate silent install commands with fields id, command, framework, confidence (0..1), rationale.
2) Fill manifest fields; include product_code and uninstall_command when detectable; set human_review:true if any field is TODO or any candidate confidence < 0.80.
3) Provide verification_hints (paths, registry keys, commands to run to smoke-test).
4) Return a PSAppDeployToolkit Deploy-Application.ps1 skeleton that uses the primary candidate command and the verification_hints.
5) Output ONLY JSON matching the schema exactly.

```

---

### 11 — Useful quick scripts / commands

### Compute sha256 (powerful for n8n cloud function)

```powershell
Get-FileHash -Algorithm SHA256 .\source_installer.exe | Select-Object -ExpandProperty Hash

```

### Check MSI product code (PowerShell)

```powershell
# require lessmsi or use Get-WmiObject on Windows
Get-WmiObject -Class Win32_Product | Where-Object { $_.Name -like '*MyApp*' }

```

---

### Appendix — checklist to verify before first live run

- [ ] Repo templates committed and schema validated.
- [ ] n8n webhook running, can download installers, compute sha256.
- [ ] OpenAI key configured in n8n; AI calls logged.
- [ ] Branch/PR creation works and files land in `products/<Product>/`.
- [ ] Jenkins job can run and has access to Windows agent(s).
- [ ] `run-candidate-tests.ps1` exists on agent image and is executable.
- [ ] VM images ready and revertible (snapshots).
- [ ] Audit storage configured and retention policy set.
- [ ] Team notified of pilot and review process.
